"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptString = exports.encryptString = void 0;
const encrypt_uint8array_1 = require("encrypt-uint8array");
const convert_1 = require("./convert");
const NONCE_STRING_FOR_PLAINTEXT = '!.M¼I§9-?nqm¹M8xRJ$krIXþE6±R<¥[';
const NONCE_BYTES_FOR_PASSWORD = [66, 46, 52, 49, 26, 175, 187, 169, 176, 21, 248, 28, 96, 11, 212, 167, 211, 134, 203, 156];
function passwordToUint8Array(password) {
    if (typeof password === 'string') {
        return new Uint8Array([...NONCE_BYTES_FOR_PASSWORD, ...encrypt_uint8array_1.encodeString(password)]);
    }
    return password;
}
async function _encryptString(string, password) {
    const input = encrypt_uint8array_1.encodeString(NONCE_STRING_FOR_PLAINTEXT + string);
    const encryptedBytes = await encrypt_uint8array_1.encryptUint8Array(input, password);
    return convert_1.bytesToPrintableString([...encryptedBytes]);
}
async function _decryptString(encryptedString, password) {
    let output = '';
    try {
        const encryptedInput = convert_1.printableStringToBytes(encryptedString);
        const decryptedBytes = await encrypt_uint8array_1.decryptUint8Array(new Uint8Array(encryptedInput), password);
        output = encrypt_uint8array_1.decodeString(decryptedBytes);
    }
    catch (_a) { }
    if (!output.startsWith(NONCE_STRING_FOR_PLAINTEXT)) {
        throw new encrypt_uint8array_1.DecryptionError('Unable to decrypt - password is incorrect or data is corrupted.');
    }
    return output.slice(NONCE_STRING_FOR_PLAINTEXT.length);
}
async function encryptString(string, password) {
    return _encryptString(string, passwordToUint8Array(password));
}
exports.encryptString = encryptString;
async function decryptString(encryptedString, password) {
    return _decryptString(encryptedString, passwordToUint8Array(password));
}
exports.decryptString = decryptString;
//# sourceMappingURL=encrypt.js.map